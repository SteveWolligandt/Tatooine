#ifndef TATOOINE_GPU_LIC_H
#define TATOOINE_GPU_LIC_H
//==============================================================================
#include <tatooine/random.h>
#include <yavin/glfunctions.h>
#include <yavin/shader.h>

#include <boost/range/algorithm/generate.hpp>

#include <tatooine/gpu/upload.h>
//==============================================================================
namespace tatooine::gpu {
//==============================================================================
struct lic_shader : yavin::shader {
  static constexpr vec<size_t, 2> num_threads{32, 32};
  //----------------------------------------------------------------------------
  lic_shader() {
    add_stage<yavin::computeshader>("@TATOOINE_LIC_COMP_SHADER@");
    create();
    set_noise_tex_bind_point(0);
    set_v_tex_bind_point(1);
  }
  //----------------------------------------------------------------------------
  void dispatch(const vec<size_t, 2>& resolution) {
    bind();
    auto num_blocks = resolution / num_threads + 1;
    yavin::gl::dispatch_compute(num_blocks(0), num_blocks(1), 1);
  }
  void set_domain_min(GLfloat x, GLfloat y) {
    set_uniform("domain_min", x, y);
  }
  void set_domain_max(GLfloat x, GLfloat y) {
    set_uniform("domain_max", x, y);
  }
  void set_v_tex_res(GLuint w, GLuint h) {
    set_uniform("v_tex_res", w, h);
  }
  void set_noise_tex_res(GLuint w, GLuint h) {
    set_uniform("noise_tex_res", w, h);
  }
  void set_v_tex_bind_point(GLint b) {set_uniform("v_tex", b);}
  void set_noise_tex_bind_point(GLint b) {set_uniform("noise_tex", b);}
  void set_num_samples(GLuint n) { set_uniform("num_samples", n); }
  void set_stepsize(GLfloat s) { set_uniform("stepsize", s); }
};
//==============================================================================
template <typename GPUReal = float, typename Real,
          template <typename> typename InterpX,
          template <typename> typename InterpY>
auto lic(const grid_sampler<Real, 2, vec<Real, 2>, InterpX, InterpY>& sampler,
         const vec<size_t, 2>& lic_tex_res, size_t num_samples, Real stepsize,
         vec<size_t, 2> noise_res = {128, 128}) {
  using namespace yavin;

  // generate noise_tex data
  std::mt19937            rand_eng{1234};
  random_uniform<GPUReal, std::mt19937> rand(0, 1, rand_eng);
  std::vector<GPUReal>                  noise_data(noise_res(0) * noise_res(1));
  boost::generate(noise_data, [&rand] { return rand(); });

  // generate textures
  auto                   v_tex = upload(sampler);
  texture<2, GPUReal, R> noise_tex(noise_data, noise_res(0), noise_res(1));
  yavin::texture<2, GPUReal, RGBA> lic_tex(lic_tex_res(0), lic_tex_res(1));

  lic_tex.bind_image_texture(0);
  noise_tex.bind(0);
  v_tex.bind(1);

  lic_shader s;
  s.set_domain_min(sampler.front(0), sampler.front(1));
  s.set_domain_max(sampler.back(0), sampler.back(1));
  s.set_v_tex_res(sampler.size(0), sampler.size(1));
  s.set_noise_tex_res(noise_res(0), noise_res(1));
  s.set_num_samples(num_samples);
  s.set_stepsize(stepsize);
  s.dispatch(lic_tex_res);

  return lic_tex;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
template <typename GPUReal = float, typename V, typename Real>
auto lic(const field<V, Real, 2, 2>& v, const grid<Real, 2>& discrete_domain,
         Real t, const vec<size_t, 2>& lic_tex_res, size_t num_samples, Real stepsize,
         vec<size_t, 2> noise_res = {128, 128}) {
  return lic<GPUReal>(resample<interpolation::linear, interpolation::linear>(
                          v, discrete_domain, t)
                          .sampler(),
                      lic_tex_res, num_samples, stepsize, noise_res);
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
template <typename GPUReal = float, typename V, typename Real>
auto lic(const field<V, Real, 2, 2>& v, const linspace<Real>& xres,
         const linspace<Real>& yres, Real t, const vec<size_t, 2>& lic_tex_res,
         size_t num_samples, Real stepsize,
         vec<size_t, 2> noise_res = {128, 128}) {
  return lic(v, grid{xres, yres}, t, lic_tex_res, num_samples, stepsize,
             noise_res);
}

//==============================================================================
}  // namespace tatooine::gpu
//==============================================================================

#endif
