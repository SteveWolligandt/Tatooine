#ifndef TATOOINE_GPU_LIC_H
#define TATOOINE_GPU_LIC_H
//==============================================================================
#include <tatooine/gpu/upload.h>
#include <tatooine/random.h>
#include <tatooine/gl/glfunctions.h>
#include <tatooine/gl/shader.h>

#include <boost/range/algorithm/generate.hpp>
//==============================================================================
namespace tatooine::gpu {
//==============================================================================
struct lic_shader : gl::shader {
  //----------------------------------------------------------------------------
  lic_shader() {
    add_stage<gl::computeshader>("@TATOOINE_LIC_COMP_SHADER@");
    create();
    set_noise_tex_bind_point(0);
    set_v_tex_bind_point(1);
  }
  //----------------------------------------------------------------------------
  void dispatch(vec<size_t, 2> const& resolution) {
    bind();
    static vec<size_t, 2> const num_threads{32, 32};
    auto                        num_blocks = resolution / num_threads + 1;
    gl::dispatch_compute(num_blocks(0), num_blocks(1), 1);
  }
  void set_domain_min(GLfloat x, GLfloat y) { set_uniform("domain_min", x, y); }
  void set_domain_max(GLfloat x, GLfloat y) { set_uniform("domain_max", x, y); }
  void set_v_tex_res(GLuint w, GLuint h) { set_uniform("v_tex_res", w, h); }
  void set_noise_tex_res(GLuint w, GLuint h) {
    set_uniform("noise_tex_res", w, h);
  }
  void set_v_tex_bind_point(GLint b) { set_uniform("v_tex", b); }
  void set_noise_tex_bind_point(GLint b) { set_uniform("noise_tex", b); }
  void set_num_samples(GLuint n) { set_uniform("num_samples", n); }
  void set_stepsize(GLfloat s) { set_uniform("stepsize", s); }
};
//==============================================================================
template <floating_point GPUReal = float, floating_point VReal,
          floating_point XReal, floating_point YReal>
auto lic(gl::tex2rg<VReal>&                         v_tex,
         grid<linspace<XReal>, linspace<YReal>> const& spatial_domain,
         vec<size_t, 2> const& lic_tex_res, size_t num_samples,
         arithmetic auto stepsize, vec<size_t, 2> noise_res /* = {256, 256}*/,
         std::seed_seq & noise_seed) -> gl::tex2rgba<GPUReal> {
  using namespace gl;

  // generate noise_tex data
  random::uniform       rand(GPUReal(0), GPUReal(1), noise_seed);
  std::vector<GPUReal> noise_data(noise_res(0) * noise_res(1));
  boost::generate(noise_data, [&rand] { return rand(); });

  // generate textures
  tex2r<GPUReal>    noise_tex{noise_data, noise_res(0), noise_res(1)};
  tex2rgba<GPUReal> lic_tex{lic_tex_res(0), lic_tex_res(1)};

  lic_tex.bind_image_texture(0);
  noise_tex.bind(0);
  v_tex.bind(1);

  lic_shader s;
  s.set_domain_min(spatial_domain.template front<0>(),
                   spatial_domain.template front<1>());
  s.set_domain_max(spatial_domain.template back<0>(),
                   spatial_domain.template back<1>());
  s.set_v_tex_res(spatial_domain.template size<0>(),
                  spatial_domain.template size<1>());
  s.set_noise_tex_res(noise_res(0), noise_res(1));
  s.set_num_samples(num_samples);
  s.set_stepsize(stepsize);
  s.dispatch(lic_tex_res);

  return lic_tex;
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
template <floating_point GPUReal = float, floating_point VReal,
          floating_point XReal, floating_point YReal>
auto lic(polymorphic::vectorfield<VReal, 2> const&          v,
         grid<linspace<XReal>, linspace<YReal>> const& spatial_domain,
         arithmetic auto t, vec<size_t, 2> const& lic_tex_res,
         size_t num_samples, arithmetic auto stepsize,
         vec<size_t, 2> noise_res, std::seed_seq & noise_seed)
    -> gl::tex2rgba<GPUReal> {
      std::cerr << "uploading..";
  auto v_tex = gpu::upload_tex<GPUReal>(sample_to_vector(v, spatial_domain, t),
                                        spatial_domain.template size<0>(),
                                        spatial_domain.template size<1>());
      std::cerr << "done\n";
  return lic<GPUReal>(v_tex, spatial_domain, lic_tex_res, num_samples, stepsize,
                      noise_res, noise_seed);
}
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
template <floating_point GPUReal = float, floating_point VReal,
          floating_point XReal, floating_point YReal>
auto lic(polymorphic::vectorfield<VReal, 2> const& v, linspace<XReal> const& xres,
         linspace<YReal> const& yres, arithmetic auto t,
         vec<size_t, 2> const& lic_tex_res, size_t num_samples,
         arithmetic auto stepsize, vec<size_t, 2> noise_res,
         std::seed_seq& noise_seed) -> gl::tex2rgba<GPUReal> {
  return lic<GPUReal>(v, grid{xres, yres}, t, lic_tex_res, num_samples,
                      stepsize, noise_res, noise_seed);
}
//==============================================================================
}  // namespace tatooine::gpu
//==============================================================================

#endif
