/**
\page grid_doc_page Grid Documentation
\tableofcontents
\section grid_doc_sec_usage Basic usage
\code{.cpp}
auto create_uniform_grid_2d() {
  tatooine::grid uniform_grid_2d{32, 64};
  // uniform_grid_2d is of type
  // tatooine::grid<tatooine::linspace<double>,
  //                tatooine::linspace<double>>

  // ...
}
\endcode
This creates a 2-dimensional uniform grid with resultion 32x64. It is in the
domain [0,0]x[1,1];

tatooine::grid is a templated class and for each dimension holds a container of
coordinates. When giving the constructor integral types (that must be > 0) a
deduction guide will be used to create an object of type
tatooine::grid<tatooine::linspace<double>, tatooine::linspace<double>>. So in
the example above uniform_grid_2d holds two instances of \ref
tatooine::linspace "tatooine::linspace<double>". The code above creates the
following as here:
\code{.cpp}
auto create_uniform_grid_2d() {
  tatooine::grid uniform_grid_2d{tatooine::linspace{0.0, 1.0, 32},
                                 tatooine::linspace{0.0, 1.0, 64}};

  // ...
}
\endcode

Candidates for other containers describing dimensions are std::vector and
std::array. These types can also be mixed which results.
\code{.cpp}
auto create_uniform_grid_2d() {
  tatooine::grid non_uniform_grid_3d{linspace{0.0, 1.0, 3},
                                     std::array{0.0, 0.9, 1.0},
                                     std::vector{0.5, 0.6, 1.0}};
  // non_uniform_grid_3d is of type
  // tatooine::grid<tatooine::linspace<double>,
  //                std::array<double, 3>,
  //                std::vector<double>>

  // ...
}
\endcode
This code creates a three-dimensional grid that is described by three
dimensions of mixed types. If possible tatooine::linspace should be taken
because here the factors for differentiating do not have to be calculated.

\section grid_doc_sec_vertex_pos Vertex Positions
\subsection grid_doc_subsec_vertex_pos_index Indexing
A tatooine::grid can be index with the parantheses-operator or the at method:
\code{.cpp}
auto create_grid_with_vertex_property() {
  tatooine::grid uniform_grid_2d{32, 64};
  auto const x_0_0 = uniform_grid_2d(0,0); // == tatooine::vec{0.0, 0.0} in this
example auto const also_x_0_0 = uniform_grid_2d.at(0,0); auto const x_3_3 =
uniform_grid_2d.at(3, 3); auto const x_31_63 = uniform_grid_2d.at(3, 3);// ==
tatooine::vec{1.0, 1.0} in this example
}
\endcode
These methods return a tatooine::vec that represents the position of the grid
index.

\subsection grid_doc_subsec_vertex_pos_iter Iterating over vertices
One can iterate in two ways over the vertices of a tatooine::grid:
auto create_grid_with_vertex_property() {
\code{.cpp}
auto iterate_over_vertex_positions() {
  tatooine::grid uniform_grid_2d{32, 64};
  for (auto const x : uniform_grid_2d.vertices()) {
    // x is an instance tatooine::vec
  }
}
\endcode

\code{.cpp}
auto iterate_over_vertex_indices() {
  tatooine::grid uniform_grid_2d{32, 64};
  uniform_grid_2d.loop_over_vertex_indices([&](auto const... indices){
    auto const x = uniform_grid_2d(indices...);
  });
}
\endcode

\section grid_doc_sec_props Properties
For storing properties of arbitrary types "type erasure" is used.

\subsection grid_doc_subsec_props_creation Adding Properties
Instances of tatooine::grid can be equipped with vertex properties that can
hold any data type. Vertex properties can created like in the following
example:
\code{.cpp}
auto create_grid_with_vertex_property() {
  tatooine::grid uniform_grid_2d{32, 64};
  auto& prop = uniform_grid_2d.add_vertex_property<double>("property_name");
  prop(11, 63) = 42.1337;
}
\endcode

prop should be a reference. Otherwise the whole property is copied and changing
the values of prop does not change the property that is held by
uniform_grid_2d.

uniform_grid_2d now holds a vertex property called "property_name". Internally
add_vertex_property creates an object whose type inherits
tatooine::dynamic_multidim_array. The code below does the same:

\code{.cpp}
auto create_grid_with_contiguous_vertex_property() {
  tatooine::grid uniform_grid_2d{32, 64};
  auto& prop =
uniform_grid_2d.add_contiguous_vertex_property<double>("property_name");
  prop(11, 63) = 42.1337;
}
\endcode

So these functions create containers that keep their memory in linear memory.
There is also a function that creates memory that is chunked:

\code{.cpp}
auto create_grid_with_chunked_vertex_property() {
  tatooine::grid uniform_grid_2d{32, 64};
  auto& prop =
uniform_grid_2d.add_chunked_vertex_property<double>("property_name");
  prop(11, 63) = 42.1337;
}
\endcode

NOTE: If a property is added that has the same name as specified than there
will not be created another property. Instead the already existing one is
returned.

If the property already exists and another container type is queried to use an
exception will be thrown. Example:
\code{.cpp}
auto create_chunked_and_contiguous_vertex_property() {
  tatooine::grid uniform_grid_2d{32, 64};
  auto& chunked_uv = uniform_grid_2d.add_chunked_vertex_property<tatooine::vec2>("uv");
  auto& contiguous_uv = uniform_grid_2d.add_contiguous_vertex_property<tatooine::vec2>("uv"); // here a std::runtime_error will be thrown
}
\endcode
\subsection grid_doc_subsec_props_get Query Properties
Because the internal type is hidden by "type erasure" one has to specify the
type again as template parameter when querying a property.
\code{.cpp}
template <typename... Dimensions>
auto query_grid_property(tatooine::grid<Dimensions...> const& g) {
  auto& property = g.vertex_property<double>("property_name");
}
\endcode
The function above receives a grid with an arbitrary number of dimensions with
arbitrary types.

An exception will be thrown if no property with name "property_name" can be
found or if a property can be found but the specified and the stored types do
not match.

\subsection  grid_doc_subsec_props_sampler Sampling Properties
A property can be sampled like that:
\code{.cpp}
auto sample_grid_property() {
  tatooine::grid g{32, 64};
  // Use reference here to avoid copying.
  auto& property = g.add_vertex_property<double>("property_name"); 

  // ...
  // Create the property data.
  // ...

  // Do not use a reference here.
  auto sampler = property.sampler(); 
  auto const sample = sampler(0.5, 0.5);
}
\endcode

The sampler() method returns an object that stores a reference to the grid and
a reference to the property so one must not use a reference!

The property can be sampled by using the paranthesis operator of the sampler
object as it is done above.

The sampler method is a template function that can get interpolation kernels as
template parameters. By default cubic interpolation kernels are used for every
dimension. So the following code produces the same results as the code above.

\code{.cpp}
auto sample_grid_property() {
  tatooine::grid g{32, 64};
  auto& property = g.add_vertex_property<double>("property_name"); 
  // ...
  auto sampler = property.sampler<tatooine::interpolation::cubic,
                                  tatooine::interpolation::cubic>(); 
  auto const sample = sampler(0.5, 0.5);
}
\endcode

One can also mix interpolation kernels:

\code{.cpp}
auto sample_grid_property() {
  tatooine::grid g{32, 64};
  auto& property = g.add_vertex_property<double>("property_name"); 
  // ...
  auto sampler = property.sampler<tatooine::interpolation::linear,
                                  tatooine::interpolation::cubic>(); 
  auto const sample = sampler(0.5, 0.5);
}
\endcode

Here the sampler interpolates linearly in the first dimension and cubicly in
the second dimension.
*/
