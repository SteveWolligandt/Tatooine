#version 450
#include "node.glsl"
layout(local_size_x = 1024) in;
//==============================================================================
layout(binding = 0, std430) buffer result_rast_buffer {
  node result_rast[];
};
layout(binding = 1, std430) buffer working_rast_buffer {
  node working_rast[];
};
layout(binding = 2, std430) buffer result_size_buffer {
  uint result_list_size[];
};
layout(binding = 3, std430) buffer working_size_buffer {
  uint working_list_size[];
};
layout(binding = 4, std430) buffer weight_buffer {
  float weights[];
};
layout(binding = 0) uniform atomic_uint num_overall_covered_pixels;
layout(binding = 1) uniform atomic_uint num_newly_covered_pixels;
//==============================================================================
uniform uint layer;
uniform uint size;
//==============================================================================
void main() {
  const uint li = gl_GlobalInvocationID.x;
  if (li >= size) { return; }
  const uint fi    = li * 2;
  const uint bi    = fi + 1;
  const uint size0 = result_list_size[li];
  const uint size1 = working_list_size[li];

  if (size1 > 0 && size0 == 0) {
    atomicCounterIncrement(num_overall_covered_pixels);
    atomicCounterIncrement(num_newly_covered_pixels);
  } else if (size0 > 0) {
    atomicCounterIncrement(num_overall_covered_pixels);
  }

  float weight = 0;
  if (layer == 0) {
    if (size1 == 1 && size0 == 0) {
      node n = working_rast[fi];
      weight = max(1, max(1, n.curvature) * abs(n.t - n.t0));

    } else if (size0 == 1 && size1 == 0) {
      node n = result_rast[fi];
      weight = max(1, max(1, n.curvature) * abs(n.t - n.t0));

    } else if (size0 + size1 == 2) {
      // n0 must be node that is seen so n0 and n1 will be swapped eventually
      node n0, n1;
      if (size0 == 2) {
         n0 = result_rast[fi];
         n1 = result_rast[bi];
      } else if (size1 == 2) {
         n0 = working_rast[fi];
         n1 = working_rast[bi];
      } else {
         n0 = result_rast[fi];
         n1 = working_rast[fi];
      }
      float cosv0v1 = dot(normalize(n0.v), normalize(n1.v));
      weight        = max(1, max(1, n0.curvature) * abs(n0.t - n0.t0)) *
               (1 - cosv0v1 * cosv0v1);
    } else {
      //weight = -2 * (size0 + size1);
      weight = -2;
    }
  } else {
    if (size0 > 0 || size1 > 0) { weight = 1; }
  }
  weights[li] = weight;
}
//==============================================================================
// void main() {
//  const ivec2 texpos = ivec2(gl_GlobalInvocationID.xy);
//  if (texpos.x >= ll0_tex_resolution.x || texpos.y >= ll0_tex_resolution.y) {
//    return;
//  }
//  const uint head_index0 = ll0_head_index(texpos);
//  const uint head_index1 = ll1_head_index(texpos);
//  const uint size0       = ll0_size_at(texpos);
//  const uint size1       = ll1_size_at(texpos);
//  const uint total_size  = size0 + size1;
//  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//  - if (total_size == 0) {
//    imageStore(weight_tex, texpos, vec4(0, 0, 0, 0));
//    return;
//  }
//
//  atomicCounterIncrement(num_overall_covered_pixels);
//  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//  - if (total_size > 2) {
//    float curv_acc      = 0;
//    uint  running_index = head_index0;
//    while (running_index != end_index) {
//      curv_acc += ll0_node_at(running_index).curvature;
//      running_index = ll0_node_at(running_index).next_index;
//    }
//    running_index = head_index1;
//    while (running_index != end_index) {
//      curv_acc += ll1_node_at(running_index).curvature;
//      running_index = ll1_node_at(running_index).next_index;
//    }
//    imageStore(weight_tex, texpos,
//               vec4(curv_acc / total_size * -total_size, 0, 0, 0));
//    return;
//  }
//  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//  - if (total_size == 1) {
//    if (size1 == 0) {
//      node n = ll0_node_at(head_index0);
//      imageStore(weight_tex, texpos, vec4(n.curvature * n.t - n.t0 + 1, 0, 0,
//      0));
//    } else {
//      node n = ll1_node_at(head_index1);
//      imageStore(weight_tex, texpos, vec4(n.curvature * n.t - n.t0 + 1, 0, 0,
//      0));
//    }
//    return;
//  }
//  // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
//  - if (total_size == 2) {
//    node        n0, n1;
//    if (size1 == 0) {
//      n0 = ll0_node_at(head_index0);
//      n1 = ll0_node_at(n0.next_index);
//    } else if (size0 == 0) {
//      n0 = ll1_node_at(head_index1);
//      n1 = ll1_node_at(n0.next_index);
//    } else {
//      n0 = ll0_node_at(head_index0);
//      n1 = ll1_node_at(head_index1);
//    }
//    const float tau0 = n0.t - n0.t0;
//    const float tau1 = n1.t - n1.t0;
//    const float c0   = n0.curvature;
//    const float c1   = n1.curvature;
//
//    const float cosangle    = dot(normalize(n0.v), normalize(n1.v));
//    const float sinsinangle = 1 - cosangle * cosangle;
//    const float weighting   = 0.5 * sinsinangle;
//
//    imageStore(
//        weight_tex, texpos,
//        vec4(weighting * (c0 * tau0 + c0 + c1 * tau1 + c1) / 2, 0, 0, 0));
//    return;
//  }
//}
