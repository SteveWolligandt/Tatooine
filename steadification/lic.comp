#version 450

layout(binding = 2, rgba32f) uniform image2D  lic_tex;
uniform sampler2D vector_tex;
uniform sampler2D noise_tex;

uniform uint num_steps;
uniform vec2 bounding_min;
uniform vec2 bounding_max;

const vec2 bounding_range = bounding_max - bounding_min;
const vec2 bounding_range_inv = 1.0 / bounding_range;

const ivec2 tex_size = imageSize(lic_tex);
const float max_tau_dist = 5;

//------------------------------------------------------------------------------
vec2 domain_pos_to_tex_pos(const vec2 x) {
  return (x - bounding_min) * bounding_range_inv;
}

//------------------------------------------------------------------------------
vec2 tex_pos_to_domain_pos(const vec2 x) {
  return x * bounding_range + bounding_min;
}

//------------------------------------------------------------------------------
vec3 sample_vf(const vec2 x) {
  const vec2 tex_pos = domain_pos_to_tex_pos(x);
  vec4 v = texture(vector_tex, tex_pos);
  const bool in_domain = v.w >= 0.5;
  
  if (in_domain)
    return vec3(normalize(v.xy), 1);
  return vec3(0,0,0);
}

//------------------------------------------------------------------------------
vec3 rk4_step(const vec2 y0, const float h) {
  const vec3 k1 = h * sample_vf(y0);
  if (k1.z == 0) return vec3(0,0,0);
  const vec3 k2 = h * sample_vf(y0 + k1.xy/2);
  if (k2.z == 0) return vec3(0,0,0);
  const vec3 k3 = h * sample_vf(y0 + k2.xy/2);
  if (k3.z == 0) return vec3(0,0,0);
  const vec3 k4 = h * sample_vf(y0 + k3.xy);
  if (k4.z == 0) return vec3(0,0,0);
  return vec3(y0 + (k1.xy + 2*k2.xy + 2*k3.xy + k4.xy) / 6, 1);
}

//------------------------------------------------------------------------------
float tau(const ivec2 pos) {
  return texelFetch(vector_tex, pos, 0).z;
}

//------------------------------------------------------------------------------
vec2 tau_gradient(const ivec2 pos) {
  float taus[3][3] = {
    {tau(pos + ivec2(-1,  1)), tau(pos + ivec2( 0,  1)), tau(pos + ivec2( 1,  1))},
    {tau(pos + ivec2(-1,  0)), tau(pos + ivec2( 0,  0)), tau(pos + ivec2( 1,  0))},
    {tau(pos + ivec2(-1, -1)), tau(pos + ivec2( 0, -1)), tau(pos + ivec2( 1, -1))}
  };
  return vec2(
      taus[0][2] + 2*taus[1][2] + taus[2][2] - 
        taus[0][0] - 2*taus[1][0] - taus[2][0],

      taus[0][0] + 2*taus[0][1] + taus[0][2] - 
        taus[2][0] - 2*taus[2][1] - taus[2][2]);
}

//------------------------------------------------------------------------------
bool is_continuous(const ivec2 pos) {
  return length(tau_gradient(pos)) <= max_tau_dist;
}

//------------------------------------------------------------------------------
vec2 convolve(const vec2 y0, const float h) {
  vec2 y = y0;
  float acc = 0;
  uint cnt = 0;
  for (uint i = 0; i < num_steps; ++i) {
    const vec3 maybe_y = rk4_step(y, h);
    if (maybe_y.z == 0) break;
    y = maybe_y.xy;

    vec2 y_tex = domain_pos_to_tex_pos(y);
    ivec2 y_tex_int = ivec2(y_tex * (tex_size - 1));
    if (y_tex.x < 0 || y_tex.x > 1 ||
        y_tex.y < 0 || y_tex.y > 1 ||
        !is_continuous(y_tex_int))
      break;

    acc += texture(noise_tex, y_tex).x;
    ++cnt;
  }

  return vec2(acc, cnt);
}

//------------------------------------------------------------------------------
layout (local_size_x = 16, local_size_y = 16) in;
void main() {
  const ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
  if (pos.x <= 0 || pos.y <= 0 ||
      pos.x >= tex_size.x - 1 || pos.y >= tex_size.y - 1)
    return;

  const vec2 tex_pos = vec2(pos) / (vec2(tex_size - 1));
  const vec2 domain_pos = tex_pos_to_domain_pos(tex_pos);

  if (sample_vf(domain_pos).z == 0) {
    imageStore(lic_tex, pos, vec4(vec3(1), 0));
    return;
  }

  if (!is_continuous(ivec2(tex_pos * (tex_size - 1)))) {
    imageStore(lic_tex, pos, vec4(1));
    return;
  }

  const float h = (bounding_max.x - bounding_min.x) / float(tex_size.x);
  const vec2 fw_conv = convolve(domain_pos, h);
  const vec2 bw_conv = convolve(domain_pos, -h);

  float lic_val =
    (texture(noise_tex, tex_pos).x + fw_conv.x + bw_conv.x) /
    (1 + fw_conv.y + bw_conv.y);

  lic_val = clamp((lic_val - 0.45) / 0.1 + 0.3, 0, 1);
  imageStore(lic_tex, pos, vec4(vec3(lic_val), 1));
  return;
}
